//  Application
//  Request
//	Response
//	Routing

// Application
const express = require('express'); 
//불러온 익스프레스 객체에는 하나의 함수가 할당되는데 그 함수를 실행하면 익스프레스 객체가 생성됩니다.
const app = express();
//익스프레스 클래스를 이용해 익스프레스 객체를 만든다고 생각하면 됩니다. 이것을 익스프레스 어플리케이션(Application)이라고 하는데 우리 코드에서는 app 상수에 할당했습니다.
//익스프레스 인스턴스 (app) 가 하나의 서버역할을 하는데 크게 보면 서버를 세팅하고 서버를 구동하는 역할을 합니다.
app.use(express.static('public'));
//서버를 세팅하는 것은 서버에 필요한 기능을 추가한다고 볼 수 있는데 익스프레스에서 서버의 기능을 미들웨어 형태로 존재합니다. 그리고 이 미들웨어서 익스프레스 인스턴스의 use() 함수로 추가할 수 있습니다. 
//예를 들어 서버에서 정적파일(static file)를 호스팅할 때는 다음과 같이 정적파일설정을 위한 미들웨어를 추가할 수 있습니다.
//앞으로 API 서버 기능을 확장하면서 필요한 미들웨어를 찾아서 추가할 것입니다. 아직 헬로 월드 코드에서는 미들웨어를 사용하지 않았습니다
//어플리케이션의 또 하나의 기능은 서버를 구동하는 역할인데요 아래 코드가 그 역할을 수행합니다.
app.listen(3000, () => {
  console.log('Example app listening on port 3000!');
});
//익스프레스 인스턴스의 listen() 함수를 이용해 서버가 클라이언트의 요청 대기 상태로 들어갔습니다. 첫번째 파라매터 3000이 대기할 포트 번호입니다. 
//두번째 파라매터는 함수인데 listen() 이 완료되면 실행되는 콜백함수입니다. 이 콜백함수가 호출되면 서버 구동이 완료되었다고 판단할 수 있습니다. 그리고 서버가 구동되었다는 메세지를 터미널에 출력합니다.
//어플리케이션은 라우팅 기능도 수행합니다. 서버는 나름대로 자원을 관리하는 몇가지 기능을 가지고 있을 것입니다. 만약 클라이언트로부터 어떤 요청이 있을때 서버는 가지고 있는 기능 중에 이에 적절한 것을 찾아서 
//응답해 줘야하는데 이 두가지를 연결해 주는 것을 라우팅이라고 합니다.
//라우팅: 클라이언트 요청과 서버의 로직을 연결하는것
//우리는 '/' 요청에 대해 다음과 같이 라우팅 로직을 설정하였습니다.

app.get('/', (req, res) => {
  res.send('Hello World!\n');
});
//app.get() 함수를 이용해 요청 메소드가 GET 이라는 것을 설정합니다. 그 첫번째 파라매터로 경로를 설정했구요. 그리고 이러한 요청이 들어왔을 경우 두번째 파라매터인 콜백 함수가 동작하도록 만들었습니다. 
//콜백함수는 req, res 두개 파라매터를 받는데요 이 부분은 다음 설명에서 이어집니다.

//Request
//콜백함수에서 전달해 주는 1번째 파라매터 req는 익스프레스 요청(Reqeust) 객체라고 합니다. 요청 객체는 말 그대로 서버로 요청한 클라이언트의 정보에 대해 담고 있습니다. 
//하나의 객체 형태로 되어 있는데 키와 함수들로 구성되어 있습니다. 우리가 사용하는 키는 아래의 것들입니다.
//req.params: url 파라매터 정보를 조회
//req.query: 쿼리 문자열을 조회
//req.body: 요청 바디를 조회

//Response
//콜백함수에서 전달해 주는 2번째 파라매터 res는 익스프레스 응답 객체(Response)라고 합니다. 응답 객체는 요청한 클라이언트에게 응답하기 위한 함수들로 구성된 객체입니다. 우리는 아래 함수들을 사용할 거에요.
//res.send()
//res.json()
//res.status()

//Router
//어플리케이션을 이용해 라우팅 로직을 만들 수 있지만 익스프레스에는 별도로 Router() 클래스를 제공합니다. 라우터 클래스를 이용하면 라우팅 로직을 좀더 구조적으로 만들 수 있습니다. 
//자세한 사용법은 이후에 계속 설명하겠습니다.

//클라이언트쪽 REST API
//서버 데이터를 구조적으로 사용하기 위한 API 디자인을 REST API라고 합니다. 무슨말인지요? 예를 들어보면 쉽게 이해됩니다. 당신이 사용자 목록을 조회하는 API를 만든다고 생각해 보세요. 
//API 주소를 어떻게 만들수 있을까요?

// /getUser
// 지금까지는 주로 이러한 방법이었습니다. (동의하지 않는 분도 있겠지만) 하지만 이렇게 설계해 보는 것을 어떨까요?
// /users
// "사용자"라는 것이 서버쪽에는 user라는 자원으로 정의할 수 있습니다. 그래서 서버의 user 자원을 조회하는 것이고 목록(복수)를 조회하기 때문에 복수형 users라는 이름으로 했습니다.
// 만약 1개의 유저를 조회한다면 어떻게 할수 있을까요? 우리는 자원 식별자로 id를 사용합니다.
// /users/:id
// 목록을 조회하는 api 뒤에 id를 파라매터로 받는 방법입니다.그럼 페이징은 어떻게 해야할까요? 페이징에는 limit, offset 파라매터를 사용할 수 있습니다.
// /users?limit=&offset  그동안 많이 사용했던 쿼리 문자열(Query string)을 사용합니다.
//마지막으로 이 api에는 숨겨진 정보가 하나있는데 메소드(Method) 명입니다. 이 api의 완벽한 표현 방법은 아래와 같습니다.

/*GET /users?limit=&offset=
GET /users/:id
리소스명이 명사로 표현 사용된다면 메소드명은 동사역할을 합니다. 그래서

GET은 "조회하다"로,
POST는 "생성하다"로,
PUT은 "갱신하다",
그리고 DELETE는 "삭제하다"라는 동사와 매칭됩니다.
만약 사용자를 추가하는 api를 설계한다면 다음과 같이 설계할 수 있습니다.

POST /users*/
//git checkout express